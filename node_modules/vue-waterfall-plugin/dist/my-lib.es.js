var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const inBrowser = typeof window !== "undefined" && window !== null;
const hasIntersectionObserver = checkIntersectionObserver();
const isEnumerable = Object.prototype.propertyIsEnumerable;
const getSymbols = Object.getOwnPropertySymbols;
function getValue(form, ...selectors) {
  const res = selectors.map((s) => {
    return s.replace(/\[(\w+)\]/g, ".$1").split(".").reduce((prev, cur) => {
      return prev && prev[cur];
    }, form);
  });
  return res;
}
function debounce(fn, delay2) {
  let timer = null;
  return function() {
    timer && clearTimeout(timer);
    timer = null;
    const args = arguments;
    const context = this;
    timer = setTimeout(() => {
      fn.call(context, args);
    }, delay2);
  };
}
function checkIntersectionObserver() {
  if (inBrowser && "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
    if (!("isIntersecting" in window.IntersectionObserverEntry.prototype)) {
      Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
        get() {
          return this.intersectionRatio > 0;
        }
      });
    }
    return true;
  }
  return false;
}
function isObject(val) {
  return typeof val === "function" || toString.call(val) === "[object Object]";
}
function isPrimitive(val) {
  return typeof val === "object" ? val === null : typeof val !== "function";
}
function isValidKey(key) {
  return key !== "__proto__" && key !== "constructor" && key !== "prototype";
}
function assignSymbols(target, ...args) {
  if (!isObject(target))
    throw new TypeError("expected the first argument to be an object");
  if (args.length === 0 || typeof Symbol !== "function" || typeof getSymbols !== "function")
    return target;
  for (const arg of args) {
    const names = getSymbols(arg);
    for (const key of names) {
      if (isEnumerable.call(arg, key))
        target[key] = arg[key];
    }
  }
  return target;
}
function assign(target, ...args) {
  let i = 0;
  if (isPrimitive(target))
    target = args[i++];
  if (!target)
    target = {};
  for (; i < args.length; i++) {
    if (isObject(args[i])) {
      for (const key of Object.keys(args[i])) {
        if (isValidKey(key)) {
          if (isObject(target[key]) && isObject(args[i][key]))
            assign(target[key], args[i][key]);
          else
            target[key] = args[i][key];
        }
      }
      assignSymbols(target, args[i]);
    }
  }
  return target;
}
function loadImage(url) {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.onload = () => {
      resolve(image);
    };
    image.onerror = () => {
      reject(new Error("Image load error"));
    };
    image.crossOrigin = "Anonymous";
    image.src = url;
  });
}
const LifecycleEnum = {
  LOADING: "loading",
  LOADED: "loaded",
  ERROR: "error"
};
const DEFAULT_OBSERVER_OPTIONS = {
  rootMargin: "0px",
  threshold: 0
};
const DEFAULT_LOADING = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
const DEFAULT_ERROR = "";
class Lazy {
  constructor(flag = true, options) {
    __publicField(this, "lazyActive", true);
    __publicField(this, "options", {
      loading: DEFAULT_LOADING,
      error: DEFAULT_ERROR,
      observerOptions: DEFAULT_OBSERVER_OPTIONS,
      log: true
    });
    __publicField(this, "_images", /* @__PURE__ */ new WeakMap());
    this.lazyActive = flag;
    this.config(options);
  }
  config(options = {}) {
    assign(this.options, options);
  }
  mount(el, binding, callback) {
    const { src, loading, error } = this._valueFormatter(binding);
    el.setAttribute("lazy", LifecycleEnum.LOADING);
    el.setAttribute("src", loading || DEFAULT_LOADING);
    if (!this.lazyActive) {
      this._setImageSrc(el, src, callback, error);
    } else {
      if (!hasIntersectionObserver) {
        this._setImageSrc(el, src, callback, error);
        this._log(() => {
          throw new Error("Not support IntersectionObserver!");
        });
      }
      this._initIntersectionObserver(el, src, callback, error);
    }
  }
  unmount(el) {
    const imgItem = this._realObserver(el);
    imgItem && imgItem.unobserve(el);
    this._images.delete(el);
  }
  _setImageSrc(el, src, callback, error) {
    if (!src)
      return;
    const preSrc = el.getAttribute("src");
    if (preSrc === src)
      return;
    loadImage(src).then((image) => {
      const { width, height } = image;
      const ratio = height / width;
      const lazyBox = el.parentNode.parentNode;
      lazyBox.style.paddingBottom = ratio * 100 + "%";
      el.setAttribute("lazy", LifecycleEnum.LOADED);
      el.removeAttribute("src");
      el.setAttribute("src", src);
      callback();
    }).catch(() => {
      const imgItem = this._realObserver(el);
      imgItem && imgItem.disconnect();
      if (error) {
        el.setAttribute("lazy", LifecycleEnum.ERROR);
        el.setAttribute("src", error);
      }
      this._log(() => {
        throw new Error(`Image failed to load!And failed src was: ${src} `);
      });
      callback();
    });
  }
  _isOpenLazy() {
    return hasIntersectionObserver && this.lazyActive;
  }
  _initIntersectionObserver(el, src, callback, error) {
    const observerOptions = this.options.observerOptions;
    this._images.set(el, new IntersectionObserver((entries) => {
      Array.prototype.forEach.call(entries, (entry) => {
        if (entry.isIntersecting) {
          const imgItem2 = this._realObserver(el);
          imgItem2 && imgItem2.unobserve(entry.target);
          this._setImageSrc(el, src, callback, error);
        }
      });
    }, observerOptions));
    const imgItem = this._realObserver(el);
    imgItem && imgItem.observe(el);
  }
  _valueFormatter(value) {
    let src = value;
    let loading = this.options.loading;
    let error = this.options.error;
    if (isObject(value)) {
      src = value.src;
      loading = value.loading || this.options.loading;
      error = value.error || this.options.error;
    }
    return {
      src,
      loading,
      error
    };
  }
  _log(callback) {
    if (this.options.log)
      callback();
  }
  _realObserver(el) {
    return this._images.get(el);
  }
}
const getItemWidth = ({ breakpoints, wrapperWidth, gutter, hasAroundGutter, initWidth }) => {
  const sizeList = Object.keys(breakpoints).map((key) => {
    return Number(key);
  }).sort((a, b) => a - b);
  let validSize = wrapperWidth;
  let breakpoint = false;
  for (const size of sizeList) {
    if (wrapperWidth <= size) {
      validSize = size;
      breakpoint = true;
      break;
    }
  }
  if (!breakpoint)
    return initWidth;
  const col = breakpoints[validSize] ? breakpoints[validSize].rowPerView : 4;
  if (hasAroundGutter)
    return (wrapperWidth - gutter) / col - gutter;
  else
    return (wrapperWidth - (col - 1) * gutter) / col;
};
function hasClass(el, className) {
  const reg = new RegExp(`(^|\\s)${className}(\\s|$)`);
  return reg.test(el.className);
}
function addClass(el, className) {
  if (hasClass(el, className))
    return;
  const newClass = el.className.split(/\s+/);
  newClass.push(className);
  el.className = newClass.join(" ");
}
const elementStyle = document.createElement("div").style;
const vendor = (() => {
  const transformNames = {
    webkit: "webkitTransform",
    Moz: "MozTransform",
    O: "OTransform",
    ms: "msTransform",
    standard: "transform"
  };
  for (const key in transformNames) {
    const val = transformNames[key];
    if (elementStyle[val] !== void 0)
      return key;
  }
  return false;
})();
function prefixStyle(style) {
  if (vendor === false)
    return false;
  if (vendor === "standard")
    return style;
  return vendor + style.charAt(0).toUpperCase() + style.substr(1);
}
var render$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { ref: "waterfallWrapper", staticClass: "waterfall-list", style: _vm.wrapperStyle }, _vm._l(_vm.list, function(item, index) {
    return _c("div", { key: _vm.getKey(item, index), ref: "waterfallItem", refInFor: true, staticClass: "waterfall-item" }, [_c("div", { staticClass: "waterfall-card" }, [_vm._t("item", null, { "item": item, "index": index, "url": _vm.getRenderURL(item) })], 2)]);
  }), 0);
};
var staticRenderFns$1 = [];
var Waterfall_vue_vue_type_style_index_0_scoped_true_lang = "";
function normalizeComponent(scriptExports, render2, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
  var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
  if (render2) {
    options.render = render2;
    options.staticRenderFns = staticRenderFns2;
    options._compiled = true;
  }
  if (functionalTemplate) {
    options.functional = true;
  }
  if (scopeId) {
    options._scopeId = "data-v-" + scopeId;
  }
  var hook;
  if (moduleIdentifier) {
    hook = function(context) {
      context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
      if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
        context = __VUE_SSR_CONTEXT__;
      }
      if (injectStyles) {
        injectStyles.call(this, context);
      }
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    };
    options._ssrRegister = hook;
  } else if (injectStyles) {
    hook = shadowMode ? function() {
      injectStyles.call(this, (options.functional ? this.parent : this).$root.$options.shadowRoot);
    } : injectStyles;
  }
  if (hook) {
    if (options.functional) {
      options._injectStyles = hook;
      var originalRender = options.render;
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }
  return {
    exports: scriptExports,
    options
  };
}
const transform = prefixStyle("transform");
const duration = prefixStyle("animation-duration");
const delay = prefixStyle("animation-delay");
const transition = prefixStyle("transition");
const fillMode = prefixStyle("animation-fill-mode");
const __vue2_script$1 = {
  props: {
    list: {
      type: Array,
      default: () => []
    },
    rowKey: {
      type: String,
      default: "id"
    },
    imgSelector: {
      type: String,
      default: "src"
    },
    width: {
      type: Number,
      default: 200
    },
    breakpoints: {
      type: Object,
      default: () => ({
        1200: {
          rowPerView: 3
        },
        800: {
          rowPerView: 2
        },
        500: {
          rowPerView: 1
        }
      })
    },
    gutter: {
      type: Number,
      default: 10
    },
    hasAroundGutter: {
      type: Boolean,
      default: true
    },
    animationPrefix: {
      type: String,
      default: "animate__animated"
    },
    animationEffect: {
      type: String,
      default: "fadeIn"
    },
    animationDuration: {
      type: Number,
      default: 1e3
    },
    animationDelay: {
      type: Number,
      default: 300
    },
    backgroundColor: {
      type: String,
      default: "#fff"
    },
    lazyload: {
      type: Boolean,
      default: true
    },
    loadProps: {
      type: Object,
      default: () => {
      }
    },
    delay: {
      type: Number,
      default: 300
    }
  },
  data() {
    return {
      wrapperWidth: 0,
      wrapperHeight: 0,
      posY: []
    };
  },
  provide() {
    return {
      lazy: new Lazy(this.lazyload, this.loadProps),
      imgLoaded: this.renderer
    };
  },
  computed: {
    colWidth() {
      return getItemWidth({
        wrapperWidth: this.wrapperWidth,
        breakpoints: this.breakpoints,
        gutter: this.gutter,
        hasAroundGutter: this.hasAroundGutter,
        initWidth: this.width
      });
    },
    cols() {
      const offset = this.hasAroundGutter ? -this.gutter : this.gutter;
      return Math.floor((this.wrapperWidth + offset) / (this.colWidth + this.gutter));
    },
    offsetX() {
      const offset = this.hasAroundGutter ? this.gutter : -this.gutter;
      const contextWidth = this.cols * (this.colWidth + this.gutter) + offset;
      return (this.wrapperWidth - contextWidth) / 2;
    },
    wrapperStyle() {
      return {
        height: `${this.wrapperHeight}px`,
        backgroundColor: this.backgroundColor
      };
    }
  },
  watch: {
    colWidth() {
      this.$nextTick(() => {
        this.renderer();
      });
    },
    gutter() {
      this.$nextTick(() => {
        this.renderer();
      });
    },
    wrapperWidth() {
      this.renderer();
    },
    list: {
      handler: function() {
        this.$nextTick(() => {
          this.renderer();
        });
      },
      deep: true
    }
  },
  mounted() {
    this.addWrapperSizeListener();
  },
  beforeDestroy() {
    this.removeWrapperSizeListener();
  },
  methods: {
    renderer: debounce(function() {
      this.layoutHandle();
    }, 300),
    layoutHandle() {
      this.initY();
      const refList = this.$refs.waterfallItem;
      if (!refList) {
        return;
      }
      if (refList.length === 0) {
        return;
      }
      for (let i = 0; i < refList.length; i++) {
        const curItem = refList[i];
        const minY = Math.min.apply(null, this.posY);
        const minYIndex = this.posY.indexOf(minY);
        const curX = this.getX(minYIndex);
        const style = curItem.style;
        if (transform)
          style[transform] = `translate3d(${curX}px,${minY}px, 0)`;
        style.width = `${this.colWidth}px`;
        const { height } = curItem.getBoundingClientRect();
        this.posY[minYIndex] += height + this.gutter;
        this.addAnimation(curItem, () => {
          const durationSec = `${this.animationDuration / 1e3}s`;
          if (transition)
            style[transition] = `transform ${durationSec}`;
        });
      }
      this.wrapperHeight = Math.max.apply(null, this.posY);
    },
    addWrapperSizeListener() {
      const dom = this.$refs.waterfallWrapper;
      if (!dom) {
        return;
      }
      this.wrapperObserver = new ResizeObserver((entries) => {
        const { width } = (entries[0] || {}).contentRect || {};
        this.wrapperWidth = width;
      });
      this.wrapperObserver.observe(dom);
    },
    removeWrapperSizeListener() {
      const dom = this.$refs.waterfallWrapper;
      if (!dom) {
        return;
      }
      this.wrapperObserver.unobserve(dom);
    },
    getX(index) {
      const count = this.hasAroundGutter ? index + 1 : index;
      return this.gutter * count + this.colWidth * index + this.offsetX;
    },
    initY() {
      this.posY = new Array(this.cols).fill(this.hasAroundGutter ? this.gutter : 0);
    },
    getRenderURL(item) {
      return getValue(item, this.imgSelector)[0];
    },
    getKey(item, index) {
      return item[this.rowKey] || index;
    },
    addAnimation(item, callback) {
      const content = item.firstChild;
      if (content && !hasClass(content, this.animationPrefix)) {
        const durationSec = `${this.animationDuration / 1e3}s`;
        const delaySec = `${this.animationDelay / 1e3}s`;
        const style = content.style;
        style.visibility = "visible";
        if (duration)
          style[duration] = durationSec;
        if (delay)
          style[delay] = delaySec;
        if (fillMode)
          style[fillMode] = "both";
        addClass(content, this.animationPrefix);
        addClass(content, this.animationEffect);
        if (callback) {
          setTimeout(() => {
            callback();
          }, this.animationDuration + this.animationDelay);
        }
      }
    }
  }
};
const __cssModules$1 = {};
var __component__$1 = /* @__PURE__ */ normalizeComponent(__vue2_script$1, render$1, staticRenderFns$1, false, __vue2_injectStyles$1, "d4d3d714", null, null);
function __vue2_injectStyles$1(context) {
  for (let o in __cssModules$1) {
    this[o] = __cssModules$1[o];
  }
}
var Waterfall = /* @__PURE__ */ function() {
  return __component__$1.exports;
}();
var render = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "lazy__box" }, [_c("div", { staticClass: "lazy__resource" }, [_c("img", { ref: "lazyRef", staticClass: "lazy__img", attrs: { "alt": "" } })])]);
};
var staticRenderFns = [];
var LazyImg_vue_vue_type_style_index_0_scoped_true_lang = "";
const __vue2_script = {
  props: {
    url: {
      type: String,
      default: ""
    }
  },
  inject: ["lazy", "imgLoaded"],
  mounted() {
    this.render();
  },
  beforeDestroy() {
    this.unRender();
  },
  methods: {
    render() {
      const el = this.$refs.lazyRef;
      if (!el)
        return;
      this.lazy.mount(el, this.url, () => {
        this.imgLoaded();
      });
    },
    unRender() {
      const el = this.$refs.lazyRef;
      if (!el)
        return;
      this.lazy.unmount(el);
    }
  }
};
const __cssModules = {};
var __component__ = /* @__PURE__ */ normalizeComponent(__vue2_script, render, staticRenderFns, false, __vue2_injectStyles, "af0d44fe", null, null);
function __vue2_injectStyles(context) {
  for (let o in __cssModules) {
    this[o] = __cssModules[o];
  }
}
var LazyImg = /* @__PURE__ */ function() {
  return __component__.exports;
}();
export { LazyImg, Waterfall };
